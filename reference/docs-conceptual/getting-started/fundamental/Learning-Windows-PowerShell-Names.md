---
ms.date: 06/05/2017
keywords: powershell,applet de commande
title: Apprentissage des noms dans Windows PowerShell
ms.assetid: b4d0fd22-8298-4ee6-82ae-9b6f2907c986
ms.openlocfilehash: 381aa619a41ccacb2ff3a4cdbc2b75b7f04282d1
ms.sourcegitcommit: cf195b090b3223fa4917206dfec7f0b603873cdf
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 04/09/2018
ms.locfileid: "30953471"
---
# <a name="learning-windows-powershell-names"></a><span data-ttu-id="59451-103">Apprentissage des noms dans Windows PowerShell</span><span class="sxs-lookup"><span data-stu-id="59451-103">Learning Windows PowerShell Names</span></span>
<span data-ttu-id="59451-104">L’apprentissage des noms et des paramètres des commandes nécessite beaucoup de temps avec la plupart des interfaces de ligne de commande.</span><span class="sxs-lookup"><span data-stu-id="59451-104">Learning names of commands and command parameters is a significant time investment with most command-line interfaces.</span></span> <span data-ttu-id="59451-105">Le problème est qu’il existe très peu de modèles, de sorte que la seule façon d’apprendre consiste à mémoriser chaque commande et chaque paramètre que vous devez utiliser régulièrement.</span><span class="sxs-lookup"><span data-stu-id="59451-105">The issue is that there are very few patterns, so the only way to learn is by memorizing each command and each parameter that you need to use on a regular basis.</span></span>

<span data-ttu-id="59451-106">Lorsque vous utilisez une nouvelle commande ou un nouveau paramètre, vous ne pouvez généralement pas utiliser les connaissances acquises, car vous devez apprendre un nouveau nom.</span><span class="sxs-lookup"><span data-stu-id="59451-106">When you work with a new command or parameter, you cannot generally use what you already know; you have to find and learn a new name.</span></span> <span data-ttu-id="59451-107">Si l’on considère la manière les interfaces croissent à partir d’un petit ensemble d’outils au gré des ajouts incrémentiels de fonctionnalités, on comprend aisément pourquoi la structure n’est pas standard.</span><span class="sxs-lookup"><span data-stu-id="59451-107">If you look at how interfaces grow from a small set of tools with incremental additions to functionality, it is easy to see why the structure is nonstandard.</span></span> <span data-ttu-id="59451-108">Avec les noms de commande, en particulier, cela peut sembler logique, car chaque commande est un outil distinct, mais il existe un meilleur moyen de gérer les noms de commande.</span><span class="sxs-lookup"><span data-stu-id="59451-108">With command names in particular, this may sound logical since each command is a separate tool, but there is a better way to handle command names.</span></span>

<span data-ttu-id="59451-109">La plupart des commandes sont conçues pour gérer des éléments du système d’exploitation ou des applications, telles que des services ou processus.</span><span class="sxs-lookup"><span data-stu-id="59451-109">Most commands are built to manage elements of the operating system or applications, such as services or processes.</span></span> <span data-ttu-id="59451-110">Les commandes portent divers noms qui peuvent ou non s’intégrer dans une famille.</span><span class="sxs-lookup"><span data-stu-id="59451-110">The commands have a variety of names that may or may not fit into a family.</span></span> <span data-ttu-id="59451-111">Par exemple, sur des systèmes Windows, vous pouvez utiliser les commandes **net start** et **net stop** pour démarrer et arrêter un service.</span><span class="sxs-lookup"><span data-stu-id="59451-111">For example, on Windows systems, you can use the **net start** and **net stop** commands to start and stop a service.</span></span> <span data-ttu-id="59451-112">Il existe un autre outil de contrôle de service plus généralisé pour Windows, qui porte un nom complètement différent, **sc**, non conforme au modèle d’affectation de noms pour les commandes de service **net**.</span><span class="sxs-lookup"><span data-stu-id="59451-112">There is another more generalized service control tool for Windows that has a completely different name, **sc**, that does not fit into the naming pattern for the **net** service commands.</span></span> <span data-ttu-id="59451-113">Pour la gestion des processus, Windows offre la commande **tasklist** pour les répertorier, et la commande **taskkill** pour les supprimer.</span><span class="sxs-lookup"><span data-stu-id="59451-113">For process management, Windows has the **tasklist** command to list processes and the **taskkill** command to kill processes.</span></span>

<span data-ttu-id="59451-114">Les commandes qui prennent des paramètres ont des spécifications de paramètre irrégulières.</span><span class="sxs-lookup"><span data-stu-id="59451-114">Commands that take parameters have irregular parameter specifications.</span></span> <span data-ttu-id="59451-115">Vous ne pouvez pas utiliser la commande **net start** pour démarrer un service sur un ordinateur distant.</span><span class="sxs-lookup"><span data-stu-id="59451-115">You cannot use the **net start** command to start a service on a remote computer.</span></span> <span data-ttu-id="59451-116">La commande **sc** démarre un service sur un ordinateur distant mais, pour spécifier celui-ci, vous devez faire précéder son nom d’une double barre oblique inverse.</span><span class="sxs-lookup"><span data-stu-id="59451-116">The **sc** command will start a service on a remote computer, but to specify the remote computer, you must prefix its name with a double backslash.</span></span> <span data-ttu-id="59451-117">Par exemple, pour démarrer le service du spouleur sur un ordinateur distant nommé DC01, tapez **sc \\\\DC01 start spooler**.</span><span class="sxs-lookup"><span data-stu-id="59451-117">For example, to start the spooler service on a remote computer named DC01, you would type **sc \\\\DC01 start spooler**.</span></span> <span data-ttu-id="59451-118">Pour afficher la liste des tâches en cours d’exécution sur DC01, vous devez utiliser le paramètre **/S** (pour « système ») et fournir le nom DC01 sans barre oblique inverse, comme suit : **tasklist S DC01**.</span><span class="sxs-lookup"><span data-stu-id="59451-118">To list tasks running on DC01, you need to use the **/S** (for "system") parameter and supply the name DC01 without backslashes, like this: **tasklist /S DC01**.</span></span>

<span data-ttu-id="59451-119">Bien qu’il existe des différences techniques importantes entre un service et un processus, il s’agit de deux exemples d’éléments faciles à gérer sur un ordinateur, dont le cycle de vie est bien défini.</span><span class="sxs-lookup"><span data-stu-id="59451-119">Although there are important technical distinctions between a service and a process, they are both examples of manageable elements on a computer that have a well-defined life cycle.</span></span> <span data-ttu-id="59451-120">Il se peut que vous souhaitiez démarrer ou arrêter un service ou un processus, ou obtenir la liste de tous les services ou processus en cours d’exécution.</span><span class="sxs-lookup"><span data-stu-id="59451-120">You may want to start or stop a service or process, or get a list of all currently running services or processes.</span></span> <span data-ttu-id="59451-121">En d’autres termes, bien qu’un service et un processus relèvent de concepts différents, les actions que nous effectuons sur un service ou un processus sont souvent conceptuellement identiques.</span><span class="sxs-lookup"><span data-stu-id="59451-121">In other words, although a service and a process are different things, the actions we perform on a service or a process are often conceptually the same.</span></span> <span data-ttu-id="59451-122">En outre, les choix que nous pouvons opérer pour personnaliser une action en spécifiant des paramètres peuvent également être similaires sur le plan conceptuel.</span><span class="sxs-lookup"><span data-stu-id="59451-122">Furthermore, choices we may make to customize an action by specifying parameters may be conceptually similar as well.</span></span>

<span data-ttu-id="59451-123">Windows PowerShell exploite ces similitudes pour réduire le nombre de noms distincts que vous devez connaître pour comprendre et utiliser les applets de commande.</span><span class="sxs-lookup"><span data-stu-id="59451-123">Windows PowerShell exploits these similarities to reduce the number of distinct names you need to know to understand and use cmdlets.</span></span>

### <a name="cmdlets-use-verb-noun-names-to-reduce-command-memorization"></a><span data-ttu-id="59451-124">Utilisation de noms de type verbe-substantif pour les applets de commande afin de réduire la mémorisation des commandes</span><span class="sxs-lookup"><span data-stu-id="59451-124">Cmdlets Use Verb-Noun Names to Reduce Command Memorization</span></span>
<span data-ttu-id="59451-125">Windows PowerShell utilise un système d’affectation de noms de type « verbe-substantif », où le nom de chaque applet de commande se compose d’un verbe standard associé à un nom spécifique à l’aide d’un trait d’union.</span><span class="sxs-lookup"><span data-stu-id="59451-125">Windows PowerShell uses a "verb-noun" naming system, where each cmdlet name consists of a standard verb hyphenated with a specific noun.</span></span> <span data-ttu-id="59451-126">Les verbes qu’utilise Windows PowerShell ne sont pas toujours des verbes anglais, mais ils désignent des actions spécifiques dans Windows PowerShell.</span><span class="sxs-lookup"><span data-stu-id="59451-126">Windows PowerShell verbs are not always English verbs, but they express specific actions in Windows PowerShell.</span></span> <span data-ttu-id="59451-127">Les noms sont très semblables à des noms communs dans n’importe quelle langue. Ils décrivent certains types d’objets qui sont importants dans l’administration du système.</span><span class="sxs-lookup"><span data-stu-id="59451-127">Nouns are very much like nouns in any language, they describe specific types of objects that are important in system administration.</span></span> <span data-ttu-id="59451-128">Il est facile de démontrer comment ces noms en deux parties contribuent à réduire l’effort d’apprentissage en examinant quelques exemples de verbes et de noms.</span><span class="sxs-lookup"><span data-stu-id="59451-128">It is easy to demonstrate how these two-part names reduce learning effort by looking at a few examples of verbs and nouns.</span></span>

<span data-ttu-id="59451-129">Les noms sont moins restreints, mais ils doivent toujours décrire l’objet de l’action d’une commande.</span><span class="sxs-lookup"><span data-stu-id="59451-129">Nouns are less restricted, but they should always describe what a command acts upon.</span></span> <span data-ttu-id="59451-130">Windows PowerShell dispose de commandes telles que **Get-Process**, **Stop-Process**, **Get-Service** et **Stop-Service**.</span><span class="sxs-lookup"><span data-stu-id="59451-130">Windows PowerShell has commands such as **Get-Process**, **Stop-Process**, **Get-Service**, and **Stop-Service**.</span></span>

<span data-ttu-id="59451-131">En cas d’utilisation de deux noms et deux verbes, la cohérence ne simplifie pas tellement l’apprentissage.</span><span class="sxs-lookup"><span data-stu-id="59451-131">In the case of two nouns and two verbs, consistency does not simplify learning that much.</span></span> <span data-ttu-id="59451-132">En revanche, si l’on considère un jeu standard de 10 verbes et 10 noms, il n’y a que 20 mots à comprendre, mais ils permettent de former 100 noms de commande distincts.</span><span class="sxs-lookup"><span data-stu-id="59451-132">However, if you look at a standard set of 10 verbs and 10 nouns, you then have only 20 words to understand, but those words can be used to form 100 distinct command names.</span></span>

<span data-ttu-id="59451-133">Souvent, vous pouvez comprendre l’action d’une commande en lisant son nom, et le nom à utiliser pour une nouvelle commande est généralement évident.</span><span class="sxs-lookup"><span data-stu-id="59451-133">Frequently, you can recognize what a command does by reading its name, and it is usually apparent what name should be used for a new command.</span></span> <span data-ttu-id="59451-134">Par exemple, une commande d’arrêt d’ordinateur peut être **Stop-Computer**.</span><span class="sxs-lookup"><span data-stu-id="59451-134">For example, a computer shutdown command might be **Stop-Computer**.</span></span> <span data-ttu-id="59451-135">Une commande permettant de répertorier tous les ordinateurs d’un réseau peut être **Get-Computer**.</span><span class="sxs-lookup"><span data-stu-id="59451-135">A command that lists all computers on a network might be **Get-Computer**.</span></span> <span data-ttu-id="59451-136">La commande permettant d’obtenir la date système est **Get-Date**.</span><span class="sxs-lookup"><span data-stu-id="59451-136">The command that gets the system date is **Get-Date**.</span></span>

<span data-ttu-id="59451-137">Vous pouvez répertorier toutes les commandes incluant un verbe particulier avec le paramètre **-Verb** pour l’applet de commande **Get-Command** (l’applet de commande **Get-Command** est décrite en détail dans la section suivante).</span><span class="sxs-lookup"><span data-stu-id="59451-137">You can list all commands that include a particular verb with the **-Verb** parameter for **Get-Command** (We will discuss **Get-Command** in detail in the next section).</span></span> <span data-ttu-id="59451-138">Par exemple, pour afficher toutes les applets de commande qui utilisent le verbe **Get**, tapez :</span><span class="sxs-lookup"><span data-stu-id="59451-138">For example, to see all cmdlets that use the verb **Get**, type:</span></span>

```
PS> Get-Command -Verb Get
CommandType     Name                            Definition
-----------     ----                            ----------
Cmdlet          Get-Acl                         Get-Acl [[-Path] <String[]>]...
Cmdlet          Get-Alias                       Get-Alias [[-Name] <String[]...
Cmdlet          Get-AuthenticodeSignature       Get-AuthenticodeSignature [-...
Cmdlet          Get-ChildItem                   Get-ChildItem [[-Path] <Stri...
...
```

<span data-ttu-id="59451-139">Le paramètre **-Noun** est encore plus utile, car il permet de voir une famille de commandes qui affectent le même type d’objet.</span><span class="sxs-lookup"><span data-stu-id="59451-139">The **-Noun** parameter is even more useful because it allows you to see a family of commands that affect the same type of object.</span></span> <span data-ttu-id="59451-140">Par exemple, si vous souhaitez afficher les commandes disponibles pour la gestion des services, tapez la commande suivante :</span><span class="sxs-lookup"><span data-stu-id="59451-140">For example, if you want to see which commands are available for managing services, type following command:</span></span>

```
PS> Get-Command -Noun Service
CommandType     Name                            Definition
-----------     ----                            ----------
Cmdlet          Get-Service                     Get-Service [[-Name] <String...
Cmdlet          New-Service                     New-Service [-Name] <String>...
Cmdlet          Restart-Service                 Restart-Service [-Name] <Str...
Cmdlet          Resume-Service                  Resume-Service [-Name] <Stri...
Cmdlet          Set-Service                     Set-Service [-Name] <String>...
Cmdlet          Start-Service                   Start-Service [-Name] <Strin...
Cmdlet          Stop-Service                    Stop-Service [-Name] <String...
Cmdlet          Suspend-Service                 Suspend-Service [-Name] <Str...
...
```

<span data-ttu-id="59451-141">Le simple fait que le schéma d’affectation de noms des commandes soit de type verbe-substantif ne signifie pas qu’une commande soit pas nécessairement une applet de commande.</span><span class="sxs-lookup"><span data-stu-id="59451-141">A command is not necessarily a cmdlet, just because it has a verb-noun naming scheme.</span></span> <span data-ttu-id="59451-142">Un exemple de commande Windows PowerShell native qui n’est pas une applet de commande, mais a un nom de type verbe-substantif, est la commande d’effacement d’une fenêtre de console, Clear-Host.</span><span class="sxs-lookup"><span data-stu-id="59451-142">One example of a native Windows PowerShell command that is not a cmdlet but has a verb-noun name, is the command for clearing a console window, Clear-Host.</span></span> <span data-ttu-id="59451-143">La commande Clear-Host est en fait une fonction interne, comme vous pouvez voir si vous exécutez dessus l’applet de commande Get-Command :</span><span class="sxs-lookup"><span data-stu-id="59451-143">The Clear-Host command is actually an internal function, as you can see if you run Get-Command against it:</span></span>

```
PS> Get-Command -Name Clear-Host

CommandType     Name                            Definition
-----------     ----                            ----------
Function        Clear-Host                      $spaceType = [System.Managem...
```

### <a name="cmdlets-use-standard-parameters"></a><span data-ttu-id="59451-144">Utilisation de paramètres standard par les applets de commande</span><span class="sxs-lookup"><span data-stu-id="59451-144">Cmdlets Use Standard Parameters</span></span>
<span data-ttu-id="59451-145">Comme mentionné précédemment, les commandes utilisées dans les interfaces de ligne de commande traditionnelles n’ont généralement pas de noms de paramètre cohérents.</span><span class="sxs-lookup"><span data-stu-id="59451-145">As noted earlier, commands used in traditional command-line interfaces do not generally have consistent parameter names.</span></span> <span data-ttu-id="59451-146">Parfois, les paramètres n’ont pas de nom du tout.</span><span class="sxs-lookup"><span data-stu-id="59451-146">Sometimes parameters do not have names at all.</span></span> <span data-ttu-id="59451-147">Quand ils en ont un, il s’agit souvent d’un caractère unique ou de mots abrégés pouvant être tapés rapidement, mais qui ne sont pas facilement compréhensibles pour des néophytes.</span><span class="sxs-lookup"><span data-stu-id="59451-147">When they do, they are often single-character or abbreviated words that can be typed rapidly but are not easily understood by new users.</span></span>

<span data-ttu-id="59451-148">Contrairement à la plupart des autres interfaces de ligne de commande traditionnelles, Windows PowerShell traite les paramètres directement et utilise cet accès direct aux paramètres en même temps que des instructions à l’adresse des développeurs afin de normaliser les noms de paramètre.</span><span class="sxs-lookup"><span data-stu-id="59451-148">Unlike most other traditional command-line interfaces, Windows PowerShell processes parameters directly, and it uses this direct access to the parameters along with developer guidance to standardize parameter names.</span></span> <span data-ttu-id="59451-149">Si cette solution ne garantit pas que chaque applet de commande soit toujours conforme aux normes, elle y contribue.</span><span class="sxs-lookup"><span data-stu-id="59451-149">Although this does not guarantee that every cmdlet will always conform to the standards, it does encourage it.</span></span>

> [!NOTE]
> <span data-ttu-id="59451-150">Lorsque vous utilisez des noms des paramètres, ceux-ci sont toujours précédés du signe « - » afin de permettre à Windows PowerShell de les identifier clairement en tant que paramètres.</span><span class="sxs-lookup"><span data-stu-id="59451-150">Parameter names always have a '-' prepended to them when you use them, to allow Windows PowerShell to clearly identify them as parameters.</span></span> <span data-ttu-id="59451-151">Dans l’exemple **Get-Command -Name Clear-Host**, le nom du paramètre est **Name**, mais il est entré sous la forme -**Name**.</span><span class="sxs-lookup"><span data-stu-id="59451-151">In the **Get-Command -Name Clear-Host** example, the parameter's name is **Name**, but it is entered as -**Name**.</span></span>

<span data-ttu-id="59451-152">Voici quelques-unes des caractéristiques générales des noms et utilisations des paramètres standard.</span><span class="sxs-lookup"><span data-stu-id="59451-152">Here are some of the general characteristics of the standard parameter names and usages.</span></span>

#### <a name="the-help-parameter-"></a><span data-ttu-id="59451-153">Paramètre Help (?)</span><span class="sxs-lookup"><span data-stu-id="59451-153">The Help Parameter (?)</span></span>
<span data-ttu-id="59451-154">Si vous spécifiez le paramètre **-?**</span><span class="sxs-lookup"><span data-stu-id="59451-154">When you specify the **-?**</span></span> <span data-ttu-id="59451-155">pour une applet de commande, celle-ci n’est pas exécutée.</span><span class="sxs-lookup"><span data-stu-id="59451-155">parameter to any cmdlet, the cmdlet is not executed.</span></span> <span data-ttu-id="59451-156">Au lieu de cela, Windows PowerShell affiche l’aide sur l’applet de commande.</span><span class="sxs-lookup"><span data-stu-id="59451-156">Instead, Windows PowerShell displays help for the cmdlet.</span></span>

#### <a name="common-parameters"></a><span data-ttu-id="59451-157">Paramètres communs</span><span class="sxs-lookup"><span data-stu-id="59451-157">Common Parameters</span></span>
<span data-ttu-id="59451-158">Windows PowerShell dispose de plusieurs paramètres appelés *paramètres communs*.</span><span class="sxs-lookup"><span data-stu-id="59451-158">Windows PowerShell has several parameters known as *common parameters*.</span></span> <span data-ttu-id="59451-159">Étant donné que ces paramètres sont contrôlés par le moteur Windows PowerShell, chaque fois qu’une applet de commande les implémente, ils se comportent de la même façon.</span><span class="sxs-lookup"><span data-stu-id="59451-159">Because these parameters are controlled by the Windows PowerShell engine, whenever they are implemented by a cmdlet, they will always behave the same way.</span></span> <span data-ttu-id="59451-160">Les paramètres communs sont **WhatIf**, **Confirm**, **Verbose**, **Debug**, **Warn**, **ErrorAction**, **ErrorVariable**, **OutVariable** et **OutBuffer**.</span><span class="sxs-lookup"><span data-stu-id="59451-160">The common parameters are **WhatIf**, **Confirm**, **Verbose**, **Debug**, **Warn**, **ErrorAction**, **ErrorVariable**, **OutVariable**, and **OutBuffer**.</span></span>

#### <a name="suggested-parameters"></a><span data-ttu-id="59451-161">Paramètres suggérés</span><span class="sxs-lookup"><span data-stu-id="59451-161">Suggested Parameters</span></span>
<span data-ttu-id="59451-162">Les principales applets de commande Windows PowerShell utilisent des noms standard pour des paramètres similaires.</span><span class="sxs-lookup"><span data-stu-id="59451-162">The Windows PowerShell core cmdlets use standard names for similar parameters.</span></span> <span data-ttu-id="59451-163">Bien que le mode d’utilisation des noms de paramètre ne soit pas imposé, il existe des instructions d’utilisation explicites visant à encourager la normalisation.</span><span class="sxs-lookup"><span data-stu-id="59451-163">Although the use of parameter names is not enforced, there is explicit guidance for usage to encourage standardization.</span></span>

<span data-ttu-id="59451-164">Par exemple, les instructions recommandent d’attribuer à un paramètre faisant référence à un ordinateur un nom de type **ComputerName**, plutôt que Serveur, Hôte, Système, Nœud ou un autre nom commun.</span><span class="sxs-lookup"><span data-stu-id="59451-164">For example, the guidance recommends naming a parameter that refers to a computer by name as **ComputerName**, rather than Server, Host, System, Node, or other common alternative words.</span></span> <span data-ttu-id="59451-165">Parmi les noms de paramètres importants suggérés figurent **Force**, **Exclude**, **Include**, **PassThru**, **Path** et **CaseSensitive**.</span><span class="sxs-lookup"><span data-stu-id="59451-165">Among the important suggested parameter names are **Force**, **Exclude**, **Include**, **PassThru**, **Path**, and **CaseSensitive**.</span></span>