---
title: Tout ce que vous avez toujours voulu savoir sur les exceptions
description: La gestion des erreurs fait partie intégrante du travail dès lors qu’il s’agit d’écrire du code.
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: cd17ae6b5ded052c93923b648155a4dda8956b34
ms.sourcegitcommit: 94c39b0d36b948d3a62707ae8a3be00efe606434
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 09/11/2020
ms.locfileid: "90012559"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="612a5-103">Tout ce que vous avez toujours voulu savoir sur les exceptions</span><span class="sxs-lookup"><span data-stu-id="612a5-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="612a5-104">La gestion des erreurs fait partie intégrante du travail dès lors qu’il s’agit d’écrire du code.</span><span class="sxs-lookup"><span data-stu-id="612a5-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="612a5-105">Le comportement attendu est couramment contrôlé par la vérification et la validation de conditions.</span><span class="sxs-lookup"><span data-stu-id="612a5-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="612a5-106">En cas de problème inattendu, nous nous tournons vers la gestion des exceptions.</span><span class="sxs-lookup"><span data-stu-id="612a5-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="612a5-107">Vous pouvez facilement gérer les exceptions générées par le code d’autres personnes, ou bien générer vos propres exceptions pour que d’autres les gèrent.</span><span class="sxs-lookup"><span data-stu-id="612a5-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="612a5-108">La [Version d’origine][] de cet article est parue sur le blog écrit par [@KevinMarquette][].</span><span class="sxs-lookup"><span data-stu-id="612a5-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="612a5-109">L’équipe PowerShell remercie Kevin d’avoir partagé ce contenu.</span><span class="sxs-lookup"><span data-stu-id="612a5-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="612a5-110">Consultez son blog à l’adresse [PowerShellExplained.com][].</span><span class="sxs-lookup"><span data-stu-id="612a5-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="612a5-111">Terminologie de base</span><span class="sxs-lookup"><span data-stu-id="612a5-111">Basic terminology</span></span>

<span data-ttu-id="612a5-112">Examinons quelques termes de base avant de commencer.</span><span class="sxs-lookup"><span data-stu-id="612a5-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="612a5-113">Exception</span><span class="sxs-lookup"><span data-stu-id="612a5-113">Exception</span></span>

<span data-ttu-id="612a5-114">Une exception ressemble à un événement créé lorsque la gestion normale des erreurs ne parvient pas à traiter le problème.</span><span class="sxs-lookup"><span data-stu-id="612a5-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="612a5-115">Par exemple, une division par zéro ou le manque de mémoire provoquent une exception.</span><span class="sxs-lookup"><span data-stu-id="612a5-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="612a5-116">Parfois, l’auteur du code que vous utilisez crée des exceptions pour certains problèmes lorsqu’ils se produisent.</span><span class="sxs-lookup"><span data-stu-id="612a5-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="612a5-117">Throw et catch</span><span class="sxs-lookup"><span data-stu-id="612a5-117">Throw and Catch</span></span>

<span data-ttu-id="612a5-118">Quand une exception se produit, on dit qu’elle est levée (throw).</span><span class="sxs-lookup"><span data-stu-id="612a5-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="612a5-119">Pour gérer une exception levée, vous devez l’intercepter ou la capturer (catch).</span><span class="sxs-lookup"><span data-stu-id="612a5-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="612a5-120">Si une exception est levée mais n’est pas capturée, le script cesse de s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="612a5-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="612a5-121">Pile des appels</span><span class="sxs-lookup"><span data-stu-id="612a5-121">The call stack</span></span>

<span data-ttu-id="612a5-122">La pile des appels est la liste des fonctions qui se sont appelées.</span><span class="sxs-lookup"><span data-stu-id="612a5-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="612a5-123">Chaque fonction appelée est ajoutée à la pile ou en haut de la liste.</span><span class="sxs-lookup"><span data-stu-id="612a5-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="612a5-124">Lorsqu’elle se termine (exit ou return), elle est supprimée de la pile.</span><span class="sxs-lookup"><span data-stu-id="612a5-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="612a5-125">Quand une exception est levée, la pile des appels est vérifiée pour qu’un gestionnaire d’exceptions puisse l’intercepter.</span><span class="sxs-lookup"><span data-stu-id="612a5-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="612a5-126">Erreurs bloquantes et non bloquantes</span><span class="sxs-lookup"><span data-stu-id="612a5-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="612a5-127">Une exception constitue généralement une erreur bloquante.</span><span class="sxs-lookup"><span data-stu-id="612a5-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="612a5-128">Une fois levée, soit elle est interceptée, soit elle met fin à l’exécution en cours.</span><span class="sxs-lookup"><span data-stu-id="612a5-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="612a5-129">Par défaut, une erreur non bloquante est générée par `Write-Error` et s’ajoute au flux de sortie sans lever d’exception.</span><span class="sxs-lookup"><span data-stu-id="612a5-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="612a5-130">C’est un point à savoir, car `Write-Error` et les autres erreurs non bloquantes ne déclenchent pas `catch`.</span><span class="sxs-lookup"><span data-stu-id="612a5-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="612a5-131">Dissimulation d’exceptions</span><span class="sxs-lookup"><span data-stu-id="612a5-131">Swallowing an exception</span></span>

<span data-ttu-id="612a5-132">Il s’agit de capturer une erreur pour se contenter de la supprimer.</span><span class="sxs-lookup"><span data-stu-id="612a5-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="612a5-133">Utilisez ce procédé avec précaution, car il peut compliquer considérablement la résolution des problèmes.</span><span class="sxs-lookup"><span data-stu-id="612a5-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="612a5-134">Syntaxe des commandes de base</span><span class="sxs-lookup"><span data-stu-id="612a5-134">Basic command syntax</span></span>

<span data-ttu-id="612a5-135">Voici un tour d’horizon rapide de la syntaxe de gestion des exceptions de base utilisée dans PowerShell.</span><span class="sxs-lookup"><span data-stu-id="612a5-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="612a5-136">Throw</span><span class="sxs-lookup"><span data-stu-id="612a5-136">Throw</span></span>

<span data-ttu-id="612a5-137">Pour créer notre propre événement d’exception, nous levons une exception avec le mot clé `throw`,</span><span class="sxs-lookup"><span data-stu-id="612a5-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="612a5-138">qui crée une exception à l’exécution. Il s’agit d’une erreur bloquante.</span><span class="sxs-lookup"><span data-stu-id="612a5-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="612a5-139">Elle est gérée par un `catch` dans une fonction d’appel ou quitte le script avec un message comme celui-ci.</span><span class="sxs-lookup"><span data-stu-id="612a5-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="612a5-140">Write-Error -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="612a5-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="612a5-141">Comme nous l’avons vu, `Write-Error` ne génère pas d’erreur bloquante par défaut.</span><span class="sxs-lookup"><span data-stu-id="612a5-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="612a5-142">Si l’on spécifie `-ErrorAction Stop` en revanche, `Write-Error` déclenche une erreur bloquante qui peut être gérée à l’aide d’un `catch`.</span><span class="sxs-lookup"><span data-stu-id="612a5-142">If you specify `-ErrorAction Stop`, `Write-Error`generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="612a5-143">Merci à Lee Dailey d’avoir rappelé cette utilisation de `-ErrorAction Stop`.</span><span class="sxs-lookup"><span data-stu-id="612a5-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="612a5-144">Cmdlet -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="612a5-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="612a5-145">Spécifié sur une fonction ou une cmdlet avancée, `-ErrorAction Stop` convertit toutes les instructions `Write-Error` en erreurs bloquantes qui interrompent l’exécution ou qui peuvent être gérées par un `catch`.</span><span class="sxs-lookup"><span data-stu-id="612a5-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="612a5-146">Try/Catch</span><span class="sxs-lookup"><span data-stu-id="612a5-146">Try/Catch</span></span>

<span data-ttu-id="612a5-147">La gestion des exceptions fonctionne ainsi dans PowerShell (et dans beaucoup d’autres langages) : on essaye (`try`) d’abord une section de code ; s’il génère une erreur, on peut l’intercepter (`catch`).</span><span class="sxs-lookup"><span data-stu-id="612a5-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="612a5-148">Voici un exemple rapide.</span><span class="sxs-lookup"><span data-stu-id="612a5-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="612a5-149">Le script `catch` s’exécute seulement en cas d’erreur bloquante.</span><span class="sxs-lookup"><span data-stu-id="612a5-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="612a5-150">Si le bloc `try` s’exécute correctement, le bloc `catch` est ignoré.</span><span class="sxs-lookup"><span data-stu-id="612a5-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="612a5-151">Try/Finally</span><span class="sxs-lookup"><span data-stu-id="612a5-151">Try/Finally</span></span>

<span data-ttu-id="612a5-152">Il peut arriver qu’il ne soit pas nécessaire de gérer une erreur, mais qu’il faille quand même exécuter du code si une exception se produit.</span><span class="sxs-lookup"><span data-stu-id="612a5-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="612a5-153">C’est le rôle d’un script `finally`.</span><span class="sxs-lookup"><span data-stu-id="612a5-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="612a5-154">Regardez cet exemple :</span><span class="sxs-lookup"><span data-stu-id="612a5-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="612a5-155">À chaque fois que l’on ouvre une ressource ou que l’on s’y connecte, il faut la fermer.</span><span class="sxs-lookup"><span data-stu-id="612a5-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="612a5-156">Si `ExecuteNonQuery()` lève une exception, la connexion n’est pas arrêtée.</span><span class="sxs-lookup"><span data-stu-id="612a5-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="612a5-157">Voici le même code à l’intérieur d’un bloc `try/finally`.</span><span class="sxs-lookup"><span data-stu-id="612a5-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="612a5-158">Dans cet exemple, la connexion est fermée qu’il se produise une erreur</span><span class="sxs-lookup"><span data-stu-id="612a5-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="612a5-159">ou non.</span><span class="sxs-lookup"><span data-stu-id="612a5-159">It also is closed if there's no error.</span></span> <span data-ttu-id="612a5-160">Le script `finally` s’exécute à chaque fois.</span><span class="sxs-lookup"><span data-stu-id="612a5-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="612a5-161">Comme l’exception n’est pas interceptée, elle est quand même propagée en haut de la pile des appels.</span><span class="sxs-lookup"><span data-stu-id="612a5-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="612a5-162">Try/Catch/Finally</span><span class="sxs-lookup"><span data-stu-id="612a5-162">Try/Catch/Finally</span></span>

<span data-ttu-id="612a5-163">Il est tout à fait possible d’utiliser `catch` et `finally` ensemble</span><span class="sxs-lookup"><span data-stu-id="612a5-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="612a5-164">dans certains scénarios, même si dans la plupart des cas ils sont employés séparément.</span><span class="sxs-lookup"><span data-stu-id="612a5-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="612a5-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="612a5-165">$PSItem</span></span>

<span data-ttu-id="612a5-166">Maintenant que nous avons vu les principes de base, nous pouvons aller un peu plus loin.</span><span class="sxs-lookup"><span data-stu-id="612a5-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="612a5-167">Dans le bloc `catch` se trouve une variable automatique (`$PSItem` ou `$_`) de type `ErrorRecord` qui contient les détails de l’exception.</span><span class="sxs-lookup"><span data-stu-id="612a5-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="612a5-168">Voici un tour d’horizon rapide de quelques propriétés de la clé.</span><span class="sxs-lookup"><span data-stu-id="612a5-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="612a5-169">Dans ces exemples, l’exception était générée en utilisant un chemin d’accès non valide dans `ReadAllText`.</span><span class="sxs-lookup"><span data-stu-id="612a5-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="612a5-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="612a5-170">PSItem.ToString()</span></span>

<span data-ttu-id="612a5-171">Cette fonction donne le message le plus propre possible pour la journalisation et la sortie générale.</span><span class="sxs-lookup"><span data-stu-id="612a5-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="612a5-172">`ToString()` est appelé automatiquement si `$PSItem` est placé à l’intérieur d’une chaîne.</span><span class="sxs-lookup"><span data-stu-id="612a5-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="612a5-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="612a5-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="612a5-174">Cette propriété contient des informations supplémentaires collectées par PowerShell sur la fonction ou le script où l’exception a été levée.</span><span class="sxs-lookup"><span data-stu-id="612a5-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="612a5-175">Voici la propriété `InvocationInfo` provenant de l’exemple d’exception créé précédemment.</span><span class="sxs-lookup"><span data-stu-id="612a5-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="612a5-176">Les informations importantes sont le nom du script (`ScriptName`), la ligne (`Line`) de code et le numéro de ligne (`ScriptLineNumber`) où l’appel a commencé.</span><span class="sxs-lookup"><span data-stu-id="612a5-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="612a5-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="612a5-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="612a5-178">Cette propriété montre l’ordre des appels de fonction qui conduisent dans le code où l’exception a été générée.</span><span class="sxs-lookup"><span data-stu-id="612a5-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="612a5-179">Il n’y a ici que des appels à des fonctions dans le même script, mais elle suivrait les appels si plusieurs scripts étaient impliqués.</span><span class="sxs-lookup"><span data-stu-id="612a5-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="612a5-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="612a5-180">$PSItem.Exception</span></span>

<span data-ttu-id="612a5-181">Il s’agit de l’exception réelle qui a été levée.</span><span class="sxs-lookup"><span data-stu-id="612a5-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="612a5-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="612a5-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="612a5-183">Il s’agit du message général qui décrit l’exception, un bon point de départ pour la résolution des problèmes.</span><span class="sxs-lookup"><span data-stu-id="612a5-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="612a5-184">La plupart des exceptions comportent un message par défaut, mais elles peuvent également être définies sur un message personnalisé lorsqu’elles sont levées.</span><span class="sxs-lookup"><span data-stu-id="612a5-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="612a5-185">Il s’agit également du message retourné lorsque `$PSItem.ToString()` est appelé, si aucun n’a été défini sur `ErrorRecord`.</span><span class="sxs-lookup"><span data-stu-id="612a5-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="612a5-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="612a5-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="612a5-187">Les exceptions peuvent contenir des exceptions internes.</span><span class="sxs-lookup"><span data-stu-id="612a5-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="612a5-188">C’est souvent le cas lorsque le code appelé intercepte une exception et en lève une autre.</span><span class="sxs-lookup"><span data-stu-id="612a5-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="612a5-189">L’exception d’origine est placée à l’intérieur de la nouvelle.</span><span class="sxs-lookup"><span data-stu-id="612a5-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="612a5-190">Nous reviendrons sur ce sujet plus tard lorsque nous parlerons de lever à nouveau des exceptions.</span><span class="sxs-lookup"><span data-stu-id="612a5-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="612a5-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="612a5-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="612a5-192">Il s’agit de l’arborescence des appels de procédure (`StackTrace`) de l’exception.</span><span class="sxs-lookup"><span data-stu-id="612a5-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="612a5-193">Contrairement à la `ScriptStackTrace` ci-dessus, celle-ci concerne les appels au code managé.</span><span class="sxs-lookup"><span data-stu-id="612a5-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="612a5-194">Cette arborescence des appels de procédure n’est accessible que si l’événement est levé à partir de code managé.</span><span class="sxs-lookup"><span data-stu-id="612a5-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="612a5-195">Ici, une fonction .NET Framework est appelée directement ; c’est tout ce que l’on peut voir dans cet exemple.</span><span class="sxs-lookup"><span data-stu-id="612a5-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="612a5-196">En général, lorsque l’on examine une arborescence des appels de procédure, on recherche l’endroit où s’arrête le code et où commencent les appels système.</span><span class="sxs-lookup"><span data-stu-id="612a5-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="612a5-197">Utilisation des exceptions</span><span class="sxs-lookup"><span data-stu-id="612a5-197">Working with exceptions</span></span>

<span data-ttu-id="612a5-198">La question des exceptions dépasse la syntaxe de base et les propriétés des exceptions.</span><span class="sxs-lookup"><span data-stu-id="612a5-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="612a5-199">Interception des exceptions typées</span><span class="sxs-lookup"><span data-stu-id="612a5-199">Catching typed exceptions</span></span>

<span data-ttu-id="612a5-200">Il est possible de choisir les exceptions à intercepter.</span><span class="sxs-lookup"><span data-stu-id="612a5-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="612a5-201">Elles possèdent en effet un type,</span><span class="sxs-lookup"><span data-stu-id="612a5-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="612a5-202">qui est vérifié pour chaque bloc `catch` jusqu’à ce qu’il en soit trouvé un qui corresponde à l’exception.</span><span class="sxs-lookup"><span data-stu-id="612a5-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="612a5-203">Il est important de comprendre que les exceptions peuvent hériter d’autres exceptions.</span><span class="sxs-lookup"><span data-stu-id="612a5-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="612a5-204">Dans l'exemple ci-dessus, `FileNotFoundException` hérite de `IOException`.</span><span class="sxs-lookup"><span data-stu-id="612a5-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="612a5-205">Par conséquent, si `IOException` arrivait en premier, ce serait elle qui serait appelée.</span><span class="sxs-lookup"><span data-stu-id="612a5-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="612a5-206">Un seul bloc catch est appelé, même s’il existe plusieurs correspondances.</span><span class="sxs-lookup"><span data-stu-id="612a5-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="612a5-207">`IOException` correspondrait avec `System.IO.PathTooLongException` ; en revanche, rien n’intercepterait `InsufficientMemoryException`, qui serait donc propagée en haut de la pile.</span><span class="sxs-lookup"><span data-stu-id="612a5-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="612a5-208">Interception de plusieurs types à la fois</span><span class="sxs-lookup"><span data-stu-id="612a5-208">Catch multiple types at once</span></span>

<span data-ttu-id="612a5-209">Il est possible d’intercepter plusieurs types d’exceptions avec la même instruction `catch`.</span><span class="sxs-lookup"><span data-stu-id="612a5-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="612a5-210">Merci à `/u/Sheppard_Ra` d’avoir suggéré cet ajout.</span><span class="sxs-lookup"><span data-stu-id="612a5-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="612a5-211">Déclenchement des exceptions typées</span><span class="sxs-lookup"><span data-stu-id="612a5-211">Throwing typed exceptions</span></span>

<span data-ttu-id="612a5-212">Il est possible de lever des exceptions typées dans PowerShell.</span><span class="sxs-lookup"><span data-stu-id="612a5-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="612a5-213">Au lieu d’appeler `throw` avec une chaîne :</span><span class="sxs-lookup"><span data-stu-id="612a5-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="612a5-214">Utilisez un accélérateur d’exception :</span><span class="sxs-lookup"><span data-stu-id="612a5-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="612a5-215">Toutefois, il est alors nécessaire de spécifier un message.</span><span class="sxs-lookup"><span data-stu-id="612a5-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="612a5-216">Vous pouvez également créer une nouvelle instance d’une exception à lever.</span><span class="sxs-lookup"><span data-stu-id="612a5-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="612a5-217">Dans ce cas, le message est facultatif, car le système possède des messages par défaut pour toutes les exceptions intégrées.</span><span class="sxs-lookup"><span data-stu-id="612a5-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="612a5-218">Si vous n’utilisez pas la version 5.0 ou une version ultérieure de PowerShell, vous devez utiliser l’ancienne approche `New-Object`.</span><span class="sxs-lookup"><span data-stu-id="612a5-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="612a5-219">Une exception typée peut être interceptée par son type, comme nous l’avons vu dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="612a5-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="612a5-220">Write-Error -Exception</span><span class="sxs-lookup"><span data-stu-id="612a5-220">Write-Error -Exception</span></span>

<span data-ttu-id="612a5-221">Ces exceptions typées peuvent être ajoutées à `Write-Error`, sachant qu’il restera possible d’intercepter (`catch`) les erreurs par type d’exception.</span><span class="sxs-lookup"><span data-stu-id="612a5-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="612a5-222">Utilisez `Write-Error` comme dans les exemples suivants :</span><span class="sxs-lookup"><span data-stu-id="612a5-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="612a5-223">Nous pouvons alors l’intercepter ainsi :</span><span class="sxs-lookup"><span data-stu-id="612a5-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="612a5-224">La grande liste des exceptions .NET</span><span class="sxs-lookup"><span data-stu-id="612a5-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="612a5-225">Avec l’aide de la [communauté Reddit/r/PowerShell][], j’ai compilé une liste principale contenant des centaines d’exceptions .NET pour compléter ce billet.</span><span class="sxs-lookup"><span data-stu-id="612a5-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="612a5-226">[La grande liste des exceptions .NET][]</span><span class="sxs-lookup"><span data-stu-id="612a5-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="612a5-227">L’idée est de rechercher dans cette liste des exceptions qui semblent adaptées à la situation.</span><span class="sxs-lookup"><span data-stu-id="612a5-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="612a5-228">Essayez d’utiliser des exceptions dans l’espace de noms `System` de base.</span><span class="sxs-lookup"><span data-stu-id="612a5-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="612a5-229">Les exceptions sont des objets</span><span class="sxs-lookup"><span data-stu-id="612a5-229">Exceptions are objects</span></span>

<span data-ttu-id="612a5-230">Si vous commencez à utiliser de nombreuses exceptions typées, n’oubliez pas qu’il s’agit d’objets.</span><span class="sxs-lookup"><span data-stu-id="612a5-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="612a5-231">Des exceptions différentes possèdent différents constructeurs et différentes propriétés.</span><span class="sxs-lookup"><span data-stu-id="612a5-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="612a5-232">Dans la documentation [FileNotFoundException][] de `System.IO.FileNotFoundException`, il apparaît que l’on peut transmettre un message et un chemin de fichier.</span><span class="sxs-lookup"><span data-stu-id="612a5-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="612a5-233">Elle possède également une propriété `FileName` qui expose ce chemin du fichier.</span><span class="sxs-lookup"><span data-stu-id="612a5-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="612a5-234">Pour découvrir d’autres constructeurs et propriétés d’objets, consultez la [documentation .NET][].</span><span class="sxs-lookup"><span data-stu-id="612a5-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="612a5-235">Exception levée plusieurs fois</span><span class="sxs-lookup"><span data-stu-id="612a5-235">Re-throwing an exception</span></span>

<span data-ttu-id="612a5-236">Si le bloc `catch` ne sert qu’à lever (`throw`) la même exception, ne l’interceptez (`catch`) pas.</span><span class="sxs-lookup"><span data-stu-id="612a5-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="612a5-237">Il ne faut intercepter (`catch`) une exception que pour la gérer ou effectuer une action quand elle se produit.</span><span class="sxs-lookup"><span data-stu-id="612a5-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="612a5-238">Il peut arriver que l’on souhaite exécuter une action sur une exception, mais lever à nouveau l’exception pour qu’elle puisse être traitée en aval :</span><span class="sxs-lookup"><span data-stu-id="612a5-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="612a5-239">par exemple, écrire un message ou consigner le problème au moment de la détection, pour le gérer plus haut dans la pile.</span><span class="sxs-lookup"><span data-stu-id="612a5-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="612a5-240">Point intéressant, si l’on appelle `throw` à partir du `catch`, il lève à nouveau l’exception actuelle.</span><span class="sxs-lookup"><span data-stu-id="612a5-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="612a5-241">Lever à nouveau l’exception permet de conserver les informations d’exécution d’origine, comme le script source et le numéro de ligne.</span><span class="sxs-lookup"><span data-stu-id="612a5-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="612a5-242">Si l’on déclenche une nouvelle exception, cela a pour effet de masquer l’endroit où l’exception a commencé.</span><span class="sxs-lookup"><span data-stu-id="612a5-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="612a5-243">Nouvelle exception levée plusieurs fois</span><span class="sxs-lookup"><span data-stu-id="612a5-243">Re-throwing a new exception</span></span>

<span data-ttu-id="612a5-244">Si vous interceptez une exception mais que vous souhaitez en lever une autre, imbriquez l’exception d’origine à l’intérieur de la nouvelle.</span><span class="sxs-lookup"><span data-stu-id="612a5-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="612a5-245">Ainsi, elle sera accessible plus bas dans la pile en tant que `$PSItem.Exception.InnerException`.</span><span class="sxs-lookup"><span data-stu-id="612a5-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="612a5-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="612a5-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="612a5-247">Le seul inconvénient de `throw` pour les exceptions brutes est que le message d’erreur pointe vers l’instruction `throw` et indique la ligne où se trouve le problème.</span><span class="sxs-lookup"><span data-stu-id="612a5-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="612a5-248">Le fait qu’il précise que l’exécution du script s’est arrêtée parce que `throw` a été appelé à la ligne 31 n’est pas pertinent pour les utilisateurs du script,</span><span class="sxs-lookup"><span data-stu-id="612a5-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="612a5-249">car non instructif.</span><span class="sxs-lookup"><span data-stu-id="612a5-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="612a5-250">Dexter Dhami a souligné que l’on peut utiliser `ThrowTerminatingError()` pour y remédier.</span><span class="sxs-lookup"><span data-stu-id="612a5-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="612a5-251">Si l’on suppose que `ThrowTerminatingError()` a été appelé à l’intérieur d’une fonction nommée `Get-Resource`, c’est cette erreur que l’on verrait.</span><span class="sxs-lookup"><span data-stu-id="612a5-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="612a5-252">Comme on peut le constater, elle pointe vers la fonction `Get-Resource` comme source du problème,</span><span class="sxs-lookup"><span data-stu-id="612a5-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="612a5-253">ce qui constitue une information utile pour l’utilisateur.</span><span class="sxs-lookup"><span data-stu-id="612a5-253">That tells the user something useful.</span></span>

<span data-ttu-id="612a5-254">Étant donné que `$PSItem` est un `ErrorRecord`, il est également possible d’utiliser `ThrowTerminatingError` de cette façon pour un nouveau déclenchement.</span><span class="sxs-lookup"><span data-stu-id="612a5-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="612a5-255">La source de l’erreur devient la cmdlet et les éléments internes de la fonction sont cachés aux utilisateurs de la cmdlet.</span><span class="sxs-lookup"><span data-stu-id="612a5-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="612a5-256">Try peut créer des erreurs bloquantes</span><span class="sxs-lookup"><span data-stu-id="612a5-256">Try can create terminating errors</span></span>

<span data-ttu-id="612a5-257">Kirk Munro signale que certaines exceptions ne constituent des erreurs bloquantes que si elles sont exécutées dans un bloc `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="612a5-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="612a5-258">Voici son exemple, qui génère une exception de division par zéro à l’exécution.</span><span class="sxs-lookup"><span data-stu-id="612a5-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="612a5-259">Appelez-le ainsi : comme vous pouvez le constater, il génère l’erreur, mais donne quand même le message.</span><span class="sxs-lookup"><span data-stu-id="612a5-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="612a5-260">Toutefois, en plaçant ce même code à l’intérieur d’un bloc `try/catch`, le résultat est différent.</span><span class="sxs-lookup"><span data-stu-id="612a5-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="612a5-261">L’erreur devient bloquante et ne génère pas le premier message.</span><span class="sxs-lookup"><span data-stu-id="612a5-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="612a5-262">Le problème est que ce code peut se trouver dans une fonction et agir différemment si quelqu’un utilise un bloc `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="612a5-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="612a5-263">Je n’ai personnellement pas rencontré ce problème, mais il s’agit d’un cas particulier à connaître.</span><span class="sxs-lookup"><span data-stu-id="612a5-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="612a5-264">$PSCmdlet.ThrowTerminatingError() dans un bloc try/catch</span><span class="sxs-lookup"><span data-stu-id="612a5-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="612a5-265">L’une des nuances de `$PSCmdlet.ThrowTerminatingError()` est qu’elle crée une erreur bloquante dans la cmdlet, mais devient une erreur non bloquante une fois sortie de la cmdlet.</span><span class="sxs-lookup"><span data-stu-id="612a5-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="612a5-266">C’est donc à la personne qui appelle la fonction de décider comment gérer l’erreur.</span><span class="sxs-lookup"><span data-stu-id="612a5-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="612a5-267">Elle peut la retransformer en erreur bloquante en utilisant `-ErrorAction Stop` ou en l’appelant à partir d’un bloc `try{...}catch{...}`.</span><span class="sxs-lookup"><span data-stu-id="612a5-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="612a5-268">Modèles de fonctions publics</span><span class="sxs-lookup"><span data-stu-id="612a5-268">Public function templates</span></span>

<span data-ttu-id="612a5-269">Par ailleurs, Kirk Munro place un bloc `try{...}catch{...}` autour de chaque bloc `begin`, `process` ou `end` dans toutes ses fonctions avancées.</span><span class="sxs-lookup"><span data-stu-id="612a5-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="612a5-270">Dans ces blocs Catch génériques, il se sert d’une ligne unique utilisant `$PSCmdlet.ThrowTerminatingError($PSItem)` pour traiter toutes les exceptions qui quittent ses fonctions.</span><span class="sxs-lookup"><span data-stu-id="612a5-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="612a5-271">Étant donné que tout se trouve dans une instruction `try` dans les fonctions, l’ensemble fonctionne de manière cohérente.</span><span class="sxs-lookup"><span data-stu-id="612a5-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="612a5-272">L’utilisateur final obtient également des erreurs propres, qui masquent le code interne.</span><span class="sxs-lookup"><span data-stu-id="612a5-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="612a5-273">Trap</span><span class="sxs-lookup"><span data-stu-id="612a5-273">Trap</span></span>

<span data-ttu-id="612a5-274">Nous nous sommes concentrés sur l’aspect `try/catch` des exceptions.</span><span class="sxs-lookup"><span data-stu-id="612a5-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="612a5-275">Cependant, il existe une fonctionnalité héritée qu’il faut mentionner avant de conclure.</span><span class="sxs-lookup"><span data-stu-id="612a5-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="612a5-276">Un bloc `trap` est placé dans un script ou une fonction pour intercepter toutes les exceptions qui se produisent dans cette portée.</span><span class="sxs-lookup"><span data-stu-id="612a5-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="612a5-277">Quand une exception se produit, le code du bloc `trap` est exécuté, puis le code normal reprend.</span><span class="sxs-lookup"><span data-stu-id="612a5-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="612a5-278">Si plusieurs exceptions se produisent, le bloc trap est appelé plusieurs fois.</span><span class="sxs-lookup"><span data-stu-id="612a5-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="612a5-279">Je n’ai personnellement jamais adopté cette approche, mais elle peut être intéressante dans les scripts d’administrateur ou de contrôleur qui journalisent toutes les exceptions, puis continuent à s’exécuter.</span><span class="sxs-lookup"><span data-stu-id="612a5-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="612a5-280">Remarques finales</span><span class="sxs-lookup"><span data-stu-id="612a5-280">Closing remarks</span></span>

<span data-ttu-id="612a5-281">Ajouter une gestion des exceptions adaptée aux scripts les rend non seulement plus stables, mais permet également de résoudre plus facilement ces exceptions.</span><span class="sxs-lookup"><span data-stu-id="612a5-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="612a5-282">Nous avons longuement parlé de `throw`, car il s’agit d’un concept fondamental pour la gestion des exceptions.</span><span class="sxs-lookup"><span data-stu-id="612a5-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="612a5-283">PowerShell propose également `Write-Error`, qui gère toutes les situations où `throw` peut être utilisé.</span><span class="sxs-lookup"><span data-stu-id="612a5-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="612a5-284">Ne concluez pas que vous devez employer `throw` après avoir lu ce billet.</span><span class="sxs-lookup"><span data-stu-id="612a5-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="612a5-285">Maintenant que j’ai pris le temps d’écrire sur la gestion des exceptions dans le détail, je vais utiliser `Write-Error -Stop` pour générer des erreurs dans mon code.</span><span class="sxs-lookup"><span data-stu-id="612a5-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="612a5-286">Je vais également suivre le conseil de Kirk et faire de `ThrowTerminatingError` mon gestionnaire d’exceptions de prédilection pour toutes les fonctions.</span><span class="sxs-lookup"><span data-stu-id="612a5-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[Version d’origine]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Communauté Reddit/r/PowerShell]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[La grande liste des exceptions .NET]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[Documentation .NET]: /dotnet/api
[.NET documentation]: /dotnet/api
